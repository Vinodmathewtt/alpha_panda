Of course. Here is the complete, production-ready code for the `risk_manager` service, designed for the Unified Log architecture.

This service acts as a critical gateway in your trading pipeline. Its sole responsibility is to intercept every trading signal generated by your strategies, apply a series of validation rules, and then either approve or reject the signal. This prevents strategies from taking on excessive risk, violating trading limits, or behaving erratically.

The design is highly modular, making it easy to add new risk rules in the future without changing the core service logic.

### 1\. `services/risk_manager/rules.py`

This new file defines the individual, testable risk rules. Each rule is a small, self-contained piece of logic.

```python
# AlphasPT_v2/services/risk_manager/rules.py

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

# A simple data structure for the result of a rule check
class RuleResult:
    def __init__(self, passed: bool, reason: Optional[str] = None):
        self.passed = passed
        self.reason = reason

class RiskRule(ABC):
    """Abstract base class for all risk validation rules."""

    @abstractmethod
    def check(self, signal: Dict[str, Any], state: 'RiskState') -> RuleResult:
        """
        Checks if a given signal violates this rule based on the current state.

        Args:
            signal: The trading signal event to be validated.
            state: The current risk state (positions, P&L) for the strategy.

        Returns:
            A RuleResult indicating if the check passed or failed.
        """
        pass

class MaxPositionValueRule(RiskRule):
    """
    Checks if a new order would cause the total position value for an
    instrument to exceed a configured limit.
    """
    def __init__(self, max_value: float):
        self.max_value = max_value

    def check(self, signal: Dict[str, Any], state: 'RiskState') -> RuleResult:
        instrument = signal['instrument_token']
        current_position_value = state.positions.get(instrument, {}).get('value', 0.0)

        # Estimate the value of the new order
        order_value = signal['quantity'] * signal.get('price', state.get_last_price(instrument))

        if signal['signal_type'] == 'BUY':
            new_position_value = current_position_value + order_value
        else: # SELL
            new_position_value = current_position_value - order_value

        if abs(new_position_value) > self.max_value:
            reason = (f"Position value limit exceeded. "
                      f"New value {new_position_value:.2f} would exceed limit {self.max_value:.2f}.")
            return RuleResult(passed=False, reason=reason)

        return RuleResult(passed=True)

class MaxDailyLossRule(RiskRule):
    """
    Checks if the strategy has already exceeded its daily loss limit.
    If so, it rejects all new orders.
    """
    def __init__(self, max_loss: float):
        # max_loss should be a positive number, e.g., 5000.0
        self.max_loss = abs(max_loss) * -1

    def check(self, signal: Dict[str, Any], state: 'RiskState') -> RuleResult:
        daily_pnl = state.daily_pnl.get('total', 0.0)

        if daily_pnl < self.max_loss:
            reason = (f"Daily loss limit breached. "
                      f"Current P&L {daily_pnl:.2f} is below limit {self.max_loss:.2f}.")
            return RuleResult(passed=False, reason=reason)

        return RuleResult(passed=True)

```

**Explanation:**

- **Modularity**: Each rule is its own class with a single `check` method. This makes them incredibly easy to test in isolation.
- **Pure Logic**: The rules are "pure"â€”they take in data (the signal and the current state) and return a result. They have no side effects and don't depend on any external systems.
- **Extensibility**: To add a new risk check (e.g., `MaxOpenOrdersRule`), you simply create a new class that inherits from `RiskRule` and implement its `check` method.

### 2\. `services/risk_manager/state.py`

This new file defines a class responsible for maintaining the real-time state needed for risk calculations (e.g., current positions, daily P\&L). It consumes events from the unified log to keep itself up-to-date.

```python
# AlphasPT_v2/services/risk_manager/state.py

from collections import defaultdict

class RiskState:
    """
    Maintains the real-time risk state for all strategies.

    This class consumes order fill and market data events to build an
    in-memory view of current positions, P&L, and last known prices.
    """
    def __init__(self):
        # In-memory state. For production, this could be backed by Redis.
        self.positions = defaultdict(dict) # strategy_id -> {instrument_token: {qty: X, value: Y}}
        self.daily_pnl = defaultdict(float) # strategy_id -> P&L
        self.last_prices = {} # instrument_token -> price

    def update_from_fill(self, fill_event: dict):
        """Updates positions and P&L based on an order fill event."""
        strategy_id = fill_event['strategy_id']
        instrument = fill_event['instrument_token']

        # This is a simplified P&L and position calculation. A real implementation
        # would be more detailed, handling average entry prices, etc.

        # Update P&L
        pnl = fill_event.get('realized_pnl', 0.0)
        self.daily_pnl[strategy_id] += pnl

        # Update Position
        # ... logic to update position quantity and value ...
        print(f"State updated for {strategy_id} due to fill.")

    def update_from_tick(self, tick_event: dict):
        """Updates the last known price for an instrument."""
        instrument = tick_event['instrument_token']
        self.last_prices[instrument] = tick_event['last_price']

    def get_last_price(self, instrument_token: int) -> float:
        """Gets the last known price, defaulting to 0 if not seen."""
        return self.last_prices.get(instrument_token, 0.0)

```

**Explanation:**

- **State Management**: This class encapsulates all the logic for tracking the state needed for risk checks. The main service doesn't need to know how this state is calculated.
- **Event-Driven**: The state is built entirely by consuming events (`orders.filled`, `market.ticks`) from the unified log. This is a core principle of the architecture.
- **Persistence (Future)**: While currently in-memory, this class could be easily modified to use Redis as its backing store, making the risk state persistent across service restarts.

### 3\. `services/risk_manager/service.py`

This is the main service file. It acts as the central stream processor, orchestrating the state and rules to validate signals.

```python
# AlphasPT_v2/services/risk_manager/service.py

import asyncio
from typing import Dict, Any

from app.services import LifespanService
from core.streaming.clients import RedpandaProducer, RedpandaConsumer, RedpandaSettings
from core.database.connection import DatabaseManager

from .state import RiskState
from .rules import MaxPositionValueRule, MaxDailyLossRule

class RiskManagerService(LifespanService):
    """
    The risk manager service validates trading signals against a set of rules.
    """
    def __init__(
        self,
        producer: RedpandaProducer,
        db_manager: DatabaseManager,
        consumer_config: RedpandaSettings,
    ):
        self.producer = producer
        self.db_manager = db_manager
        self.consumer_config = consumer_config

        self.state = RiskState()
        self.rules = {} # strategy_id -> [list of rule instances]

        self.consumer = RedpandaConsumer(
            self.consumer_config,
            topics=["trading.signals.generated", "orders.filled", "market.ticks"]
        )
        self._is_running = False
        self._task = None

    async def start(self):
        """Loads risk profiles and starts the consumer loop."""
        print("ðŸš€ Starting Risk Manager Service...")
        await self._load_risk_rules()
        self._is_running = True
        self._task = asyncio.create_task(self._consume_loop())
        print("âœ… Risk Manager Service started.")

    async def stop(self):
        """Stops the consumer loop."""
        print("ðŸ›‘ Stopping Risk Manager Service...")
        self._is_running = False
        if self._task:
            self._task.cancel()
        self.consumer.close()
        print("âœ… Risk Manager Service stopped.")

    async def _consume_loop(self):
        """Main loop to consume and process events."""
        while self._is_running:
            try:
                msg = self.consumer.consume(timeout=1.0)
                if msg is None:
                    await asyncio.sleep(0.01)
                    continue

                event_type = msg.get('event_type')
                if event_type == 'trading_signal':
                    await self._handle_signal(msg)
                elif event_type == 'order_fill':
                    self.state.update_from_fill(msg)
                elif event_type == 'market_tick':
                    self.state.update_from_tick(msg)

            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Error in Risk Manager consumer loop: {e}")
                await asyncio.sleep(5)

    async def _handle_signal(self, signal: Dict[str, Any]):
        """Applies all relevant risk rules to a trading signal."""
        strategy_id = signal['strategy_id']
        rules_for_strategy = self.rules.get(strategy_id, [])

        if not rules_for_strategy:
            # No rules configured, so we approve the signal by default
            self.producer.produce("trading.signals.validated", signal)
            return

        for rule in rules_for_strategy:
            result = rule.check(signal, self.state)
            if not result.passed:
                print(f"Signal REJECTED for {strategy_id}: {result.reason}")
                rejected_event = {
                    "original_signal": signal,
                    "reason": result.reason,
                    "timestamp": asyncio.get_event_loop().time()
                }
                self.producer.produce("trading.signals.rejected", rejected_event)
                return # Stop processing on the first failure

        # If all rules passed
        print(f"Signal APPROVED for {strategy_id}")
        self.producer.produce("trading.signals.validated", signal)

    async def _load_risk_rules(self):
        """Loads risk profiles from the database and builds rule instances."""
        # In a real system, this would query the PostgreSQL database for risk profiles.
        # For this example, we'll use a hardcoded configuration.
        risk_profiles = {
            "Momentum_NIFTY50_1": {
                "max_position_value": 500000.0,
                "max_daily_loss": 25000.0,
            },
            "MeanReversion_BANKNIFTY_1": {
                "max_position_value": 750000.0,
                "max_daily_loss": 30000.0,
            }
        }

        for strategy_id, profile in risk_profiles.items():
            self.rules[strategy_id] = []
            if "max_position_value" in profile:
                self.rules[strategy_id].append(MaxPositionValueRule(profile["max_position_value"]))
            if "max_daily_loss" in profile:
                self.rules[strategy_id].append(MaxDailyLossRule(profile["max_daily_loss"]))

        print(f"Loaded risk rules for {len(self.rules)} strategies.")
```

**Explanation:**

- **Stream Processor**: The service acts as a classic stream processor. It consumes events from multiple topics, updates its internal state, and produces new events based on its logic.
- **Configuration-Driven**: The `_load_risk_rules` method is responsible for loading the risk profiles (from the database in a real system) and constructing the appropriate rule objects. To change a risk limit, you would update the database, and the service would pick up the change on its next restart.
- **Fail-Fast Logic**: The `_handle_signal` method iterates through the rules for a given strategy. The moment a single rule fails, it rejects the signal and stops processing. This is an efficient and safe approach.
- **Default Pass**: If no rules are configured for a strategy, the service defaults to approving the signal. This is a design choice that you could change to a "default deny" policy if your requirements are stricter.
