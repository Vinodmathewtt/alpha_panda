"""Trading signal types and definitions for AlphaPT strategy framework."""

from enum import Enum
from dataclasses import dataclass, asdict
from typing import Dict, Any, Optional
from decimal import Decimal
from datetime import datetime, timezone


class SignalType(Enum):
    """Trading signal types."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    EXIT = "EXIT"
    STOP_LOSS = "STOP_LOSS"
    TAKE_PROFIT = "TAKE_PROFIT"


class SignalStrength(Enum):
    """Signal strength levels."""
    WEAK = 0.3
    MODERATE = 0.5
    STRONG = 0.7
    VERY_STRONG = 0.9


class OrderType(Enum):
    """Order types for signal execution."""
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP_LOSS = "SL"
    STOP_LOSS_MARKET = "SLM"


@dataclass
class TradingSignal:
    """Trading signal with comprehensive metadata.
    
    This class represents a trading signal generated by a strategy,
    containing all necessary information for order execution and
    risk management validation.
    """
    
    # Core signal information
    strategy_name: str
    instrument_token: int
    tradingsymbol: str
    exchange: str
    signal_type: SignalType
    quantity: int
    
    # Price information
    price: Optional[Decimal] = None
    trigger_price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    
    # Signal metadata
    strength: SignalStrength = SignalStrength.MODERATE
    confidence: float = 0.5
    reason: str = ""
    
    # Order execution details
    order_type: OrderType = OrderType.MARKET
    product: str = "MIS"  # MIS, CNC, NRML
    validity: str = "DAY"  # DAY, IOC
    variety: str = "regular"  # regular, amo, co, iceberg
    
    # Strategy routing configuration
    paper_trade: bool = True
    live_trade: bool = False
    
    # Risk parameters
    position_size_pct: Optional[float] = None
    max_loss_pct: Optional[float] = None
    
    # Timing information
    timestamp: Optional[datetime] = None
    expiry_time: Optional[datetime] = None
    
    # Additional metadata
    strategy_version: str = "1.0"
    signal_id: Optional[str] = None
    parent_signal_id: Optional[str] = None
    tags: Dict[str, Any] = None
    
    def __post_init__(self):
        """Post-initialization processing."""
        if self.timestamp is None:
            self.timestamp = datetime.now(timezone.utc)
        
        if self.tags is None:
            self.tags = {}
        
        # Generate signal ID if not provided
        if self.signal_id is None:
            self.signal_id = f"{self.strategy_name}_{self.instrument_token}_{int(self.timestamp.timestamp())}"
        
        # Validate signal
        self._validate()
    
    def _validate(self):
        """Validate signal parameters."""
        if self.quantity <= 0:
            raise ValueError("Quantity must be positive")
        
        if self.confidence < 0 or self.confidence > 1:
            raise ValueError("Confidence must be between 0 and 1")
        
        if self.price is not None and self.price <= 0:
            raise ValueError("Price must be positive")
        
        if self.signal_type in [SignalType.BUY, SignalType.SELL] and not self.tradingsymbol:
            raise ValueError("Trading symbol required for BUY/SELL signals")
    
    def should_route_to_paper(self) -> bool:
        """Check if signal should be routed to paper trading."""
        return self.paper_trade
    
    def should_route_to_live(self) -> bool:
        """Check if signal should be routed to live trading."""
        return self.live_trade
    
    def is_buy_signal(self) -> bool:
        """Check if this is a buy signal."""
        return self.signal_type in [SignalType.BUY]
    
    def is_sell_signal(self) -> bool:
        """Check if this is a sell signal."""
        return self.signal_type in [SignalType.SELL, SignalType.EXIT]
    
    def is_exit_signal(self) -> bool:
        """Check if this is an exit signal."""
        return self.signal_type in [SignalType.EXIT, SignalType.STOP_LOSS, SignalType.TAKE_PROFIT]
    
    def is_strong_signal(self) -> bool:
        """Check if this is a strong confidence signal."""
        return self.strength in [SignalStrength.STRONG, SignalStrength.VERY_STRONG]
    
    def get_market_value(self) -> Optional[Decimal]:
        """Calculate market value of the signal."""
        if self.price is not None:
            return self.price * Decimal(self.quantity)
        return None
    
    def get_risk_value(self) -> Optional[Decimal]:
        """Calculate risk value if stop loss is set."""
        if self.price is not None and self.stop_loss is not None:
            price_diff = abs(self.price - self.stop_loss)
            return price_diff * Decimal(self.quantity)
        return None
    
    def is_expired(self) -> bool:
        """Check if signal has expired."""
        if self.expiry_time is None:
            return False
        return datetime.now(timezone.utc) > self.expiry_time
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for serialization."""
        data = asdict(self)
        
        # Convert enums to values
        data['signal_type'] = self.signal_type.value
        data['strength'] = self.strength.value
        data['order_type'] = self.order_type.value
        
        # Convert datetime to ISO string
        if self.timestamp:
            data['timestamp'] = self.timestamp.isoformat()
        if self.expiry_time:
            data['expiry_time'] = self.expiry_time.isoformat()
        
        # Convert Decimal to float for JSON serialization
        if self.price:
            data['price'] = float(self.price)
        if self.trigger_price:
            data['trigger_price'] = float(self.trigger_price)
        if self.stop_loss:
            data['stop_loss'] = float(self.stop_loss)
        if self.take_profit:
            data['take_profit'] = float(self.take_profit)
        
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TradingSignal':
        """Create signal from dictionary."""
        # Convert string enums back to enum objects
        if 'signal_type' in data and isinstance(data['signal_type'], str):
            data['signal_type'] = SignalType(data['signal_type'])
        
        if 'strength' in data and isinstance(data['strength'], (int, float)):
            # Find matching strength enum
            for strength in SignalStrength:
                if abs(strength.value - data['strength']) < 0.01:
                    data['strength'] = strength
                    break
        
        if 'order_type' in data and isinstance(data['order_type'], str):
            data['order_type'] = OrderType(data['order_type'])
        
        # Convert ISO strings back to datetime
        if 'timestamp' in data and isinstance(data['timestamp'], str):
            data['timestamp'] = datetime.fromisoformat(data['timestamp'].replace('Z', '+00:00'))
        
        if 'expiry_time' in data and isinstance(data['expiry_time'], str):
            data['expiry_time'] = datetime.fromisoformat(data['expiry_time'].replace('Z', '+00:00'))
        
        # Convert floats back to Decimal for price fields
        for price_field in ['price', 'trigger_price', 'stop_loss', 'take_profit']:
            if price_field in data and data[price_field] is not None:
                data[price_field] = Decimal(str(data[price_field]))
        
        return cls(**data)
    
    def update_routing(self, paper_trade: bool = None, live_trade: bool = None):
        """Update signal routing configuration."""
        if paper_trade is not None:
            self.paper_trade = paper_trade
        if live_trade is not None:
            self.live_trade = live_trade
    
    def add_tag(self, key: str, value: Any):
        """Add metadata tag to signal."""
        self.tags[key] = value
    
    def get_tag(self, key: str, default: Any = None) -> Any:
        """Get metadata tag value."""
        return self.tags.get(key, default)
    
    def copy(self) -> 'TradingSignal':
        """Create a copy of the signal."""
        return TradingSignal.from_dict(self.to_dict())
    
    def __str__(self) -> str:
        """String representation of the signal."""
        return (f"TradingSignal({self.strategy_name}: {self.signal_type.value} "
                f"{self.quantity} {self.tradingsymbol} @ {self.price}, "
                f"strength={self.strength.value}, confidence={self.confidence:.2f})")
    
    def __repr__(self) -> str:
        """Detailed representation of the signal."""
        return self.__str__()


# Signal utility functions

def create_buy_signal(
    strategy_name: str,
    instrument_token: int,
    tradingsymbol: str,
    exchange: str,
    quantity: int,
    price: Optional[Decimal] = None,
    strength: SignalStrength = SignalStrength.MODERATE,
    **kwargs
) -> TradingSignal:
    """Utility function to create a BUY signal."""
    return TradingSignal(
        strategy_name=strategy_name,
        instrument_token=instrument_token,
        tradingsymbol=tradingsymbol,
        exchange=exchange,
        signal_type=SignalType.BUY,
        quantity=quantity,
        price=price,
        strength=strength,
        **kwargs
    )


def create_sell_signal(
    strategy_name: str,
    instrument_token: int,
    tradingsymbol: str,
    exchange: str,
    quantity: int,
    price: Optional[Decimal] = None,
    strength: SignalStrength = SignalStrength.MODERATE,
    **kwargs
) -> TradingSignal:
    """Utility function to create a SELL signal."""
    return TradingSignal(
        strategy_name=strategy_name,
        instrument_token=instrument_token,
        tradingsymbol=tradingsymbol,
        exchange=exchange,
        signal_type=SignalType.SELL,
        quantity=quantity,
        price=price,
        strength=strength,
        **kwargs
    )


def create_exit_signal(
    strategy_name: str,
    instrument_token: int,
    tradingsymbol: str,
    exchange: str,
    quantity: int,
    price: Optional[Decimal] = None,
    reason: str = "",
    **kwargs
) -> TradingSignal:
    """Utility function to create an EXIT signal."""
    return TradingSignal(
        strategy_name=strategy_name,
        instrument_token=instrument_token,
        tradingsymbol=tradingsymbol,
        exchange=exchange,
        signal_type=SignalType.EXIT,
        quantity=quantity,
        price=price,
        reason=reason,
        **kwargs
    )